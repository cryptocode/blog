<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Async CPU bound workers in Zig |  ~/cryptocode</title>
<meta name="keywords" content="">
<meta name="description" content="Zig has async/await support, which is typically used for IO bound operations.
In this article, however, we&rsquo;ll use async/await to simplify writing a simple concurrent worker.
Goal: use all the cores on the machine to find a randomly selected 64-bit number whose lower N bits are all cleared.
How it works Instead of manually spinning up threads, we&rsquo;re just going to use async/await, along with pub const io_mode = .evented; which informs the standard library to use a non-blocking event loop.">
<meta name="author" content="">
<link rel="canonical" href="https://cryptocode.github.io/blog/docs/async/">
<link crossorigin="anonymous" href="/blog/assets/css/stylesheet.31670b680bf0c33daf591b5847a304d489f83cb2bc3d2971d5f25009e51af4ca.css" integrity="sha256-MWcLaAvwwz2vWRtYR6ME1In4PLK8PSlx1fJQCeUa9Mo=" rel="preload stylesheet" as="style"><link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Gentium+Plus:ital,wght@0,400;0,700;1,400;1,700&display=swap" rel="stylesheet">
<link rel="icon" href="https://cryptocode.github.io/blog/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://cryptocode.github.io/blog/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://cryptocode.github.io/blog/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://cryptocode.github.io/blog/apple-touch-icon.png">
<link rel="mask-icon" href="https://cryptocode.github.io/blog/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript><meta property="og:title" content="Async CPU bound workers in Zig" />
<meta property="og:description" content="Zig has async/await support, which is typically used for IO bound operations.
In this article, however, we&rsquo;ll use async/await to simplify writing a simple concurrent worker.
Goal: use all the cores on the machine to find a randomly selected 64-bit number whose lower N bits are all cleared.
How it works Instead of manually spinning up threads, we&rsquo;re just going to use async/await, along with pub const io_mode = .evented; which informs the standard library to use a non-blocking event loop." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cryptocode.github.io/blog/docs/async/" />
<meta property="og:image" content="https://cryptocode.github.io/blog/images/mondrian.png" />
<meta property="article:section" content="docs" />
<meta property="article:published_time" content="2021-05-02T10:00:00+02:00" />
<meta property="article:modified_time" content="2021-05-02T10:00:00+02:00" />

<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:image" content="https://cryptocode.github.io/blog/images/mondrian.png" />
<meta name="twitter:title" content="Async CPU bound workers in Zig"/>
<meta name="twitter:description" content="Zig has async/await support, which is typically used for IO bound operations.
In this article, however, we&rsquo;ll use async/await to simplify writing a simple concurrent worker.
Goal: use all the cores on the machine to find a randomly selected 64-bit number whose lower N bits are all cleared.
How it works Instead of manually spinning up threads, we&rsquo;re just going to use async/await, along with pub const io_mode = .evented; which informs the standard library to use a non-blocking event loop."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Docs",
      "item": "https://cryptocode.github.io/blog/docs/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Async CPU bound workers in Zig",
      "item": "https://cryptocode.github.io/blog/docs/async/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Async CPU bound workers in Zig",
  "name": "Async CPU bound workers in Zig",
  "description": "Zig has async/await support, which is typically used for IO bound operations.\nIn this article, however, we\u0026rsquo;ll use async/await to simplify writing a simple concurrent worker.\nGoal: use all the cores on the machine to find a randomly selected 64-bit number whose lower N bits are all cleared.\nHow it works Instead of manually spinning up threads, we\u0026rsquo;re just going to use async/await, along with pub const io_mode = .evented; which informs the standard library to use a non-blocking event loop.",
  "keywords": [
    
  ],
  "articleBody": "Zig has async/await support, which is typically used for IO bound operations.\nIn this article, however, we’ll use async/await to simplify writing a simple concurrent worker.\nGoal: use all the cores on the machine to find a randomly selected 64-bit number whose lower N bits are all cleared.\nHow it works Instead of manually spinning up threads, we’re just going to use async/await, along with pub const io_mode = .evented; which informs the standard library to use a non-blocking event loop. Workers ensure the event loop yields to a worker thread by calling startCpuBoundOperation\nFirst we query the number of logical CPU cores. Then we allocate an array with enough space for an async frame for each core.\nThen we simply call async worker(...) for each CPU and stuff the resulting frame into the array.\nNext, we loop through the frames and await the result, which we print. While this is already simple, #5263 may make it even simpler.\nNow we face a small challenge: when a worker has found the solution, how do we tell the other workers to stop working on the problem?\nEasy enough - we pass a completion token when doing the async call (just a pointer to bool) which the winning worker atomically sets. All workers then check this flag.\nIf the completion token is set, we simply break out of the worker loop.\nI think the end result is quite clean concurrency code (requires a recent master build):\nconst std = @import(\"std\"); pub const io_mode = .evented; pub fn main() !void { var cpu: u64 = try std.Thread.getCpuCount(); // Allocate room for an async frame for every // logical cpu core var promises = try std.heap.page_allocator.alloc(@Frame(worker), cpu); defer std.heap.page_allocator.free(promises); // Start a worker on every cpu var completion_token: bool = false; while (cpu \u003e 0) : (cpu -= 1) { promises[cpu - 1] = async worker(cpu, \u0026completion_token); } std.debug.print(\"Working...\\n\", .{}); // Wait for a worker to find the solution for (promises) |*future| { var result = await future; if (result != 0) { std.debug.print(\"The answer is {x}\\n\", .{result}); } } } fn worker(seed: u64, completion_token: *bool) u64 { // Inform the event loop we're cpu bound. // This effectively puts a worker on every logical core. std.event.Loop.startCpuBoundOperation(); // Seed the random number generator so each worker // look at different numbers var prng = std.rand.DefaultPrng.init(seed); const random = prng.random(); while (true) { var attempt = random.int(u64); // We're looking for a number whose N lower bits // are zero. Feel free to change the constant to // make this take a longer or shorter amount of time. if (attempt \u0026 0xffffff == 0) { // Tell other workers we're done @atomicStore(bool, completion_token, true, std.builtin.AtomicOrder.Release); std.debug.print(\"I found the answer!\\n\", .{}); return attempt; } // Check if another worker has solved it, in which // case we stop working on the problem. if (@atomicLoad(bool, completion_token, std.builtin.AtomicOrder.Acquire)) { std.debug.print(\"Another worker won\\n\", .{}); break; } } return 0; } Run the program and observe all cpu cores get to work using htop or similar (you may have to adjust 0xffffff if it’s too fast or too slow)\nEdit: some clarifications thanks to Protty on Discord\n",
  "wordCount" : "527",
  "inLanguage": "en",
  "image": "https://cryptocode.github.io/blog/images/mondrian.png","datePublished": "2021-05-02T10:00:00+02:00",
  "dateModified": "2021-05-02T10:00:00+02:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://cryptocode.github.io/blog/docs/async/"
  },
  "publisher": {
    "@type": "Organization",
    "name": " ~/cryptocode",
    "logo": {
      "@type": "ImageObject",
      "url": "https://cryptocode.github.io/blog/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://cryptocode.github.io/blog/" accesskey="h" title=" ~/cryptocode (Alt + H)">
                <img src="https://cryptocode.github.io/blog/images/mondrian.png" alt="" aria-label="logo"
                    height="35"> ~/cryptocode</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      Async CPU bound workers in Zig
    </h1>
    <div class="post-meta"><span title='2021-05-02 10:00:00 +0200 +0200'>May 2, 2021</span>

</div>
  </header> 
  <div class="post-content"><p>Zig has <a href="https://ziglang.org/documentation/0.7.1/#Async-and-Await">async/await support</a>, which is typically used for IO bound operations.</p>
<p>In this article, however, we&rsquo;ll use async/await to simplify writing a simple concurrent worker.</p>
<p><strong>Goal: use all the cores on the machine to find a randomly selected 64-bit number whose lower N bits are all cleared.</strong></p>
<h3 id="how-it-works">How it works<a hidden class="anchor" aria-hidden="true" href="#how-it-works">#</a></h3>
<p>Instead of manually spinning up threads, we&rsquo;re just going to use async/await, along with <code>pub const io_mode = .evented;</code> which informs the standard library to use a non-blocking event loop. Workers ensure the event loop yields to a worker thread by calling <code>startCpuBoundOperation</code></p>
<p>First we query the number of logical CPU cores. Then we allocate an array with enough space for an <em>async frame</em> for each core.</p>
<p>Then we simply call <code>async worker(...)</code> for each CPU and stuff the resulting frame into the array.</p>
<p>Next, we loop through the frames and await the result, which we print. While this is already simple, <a href="https://github.com/ziglang/zig/issues/5263">#5263</a> may make it even simpler.</p>
<p>Now we face a small challenge: when a worker has found the solution, how do we tell the other workers to stop working on the problem?</p>
<p>Easy enough - we pass a completion token when doing the async call (just a pointer to bool) which the winning worker atomically sets. All workers then <em>check</em> this flag.</p>
<p>If the completion token is set, we simply break out of the worker loop.</p>
<p>I think the end result is quite clean concurrency code (requires a recent master build):</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-zig" data-lang="zig"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> std <span style="color:#f92672">=</span> @import(<span style="color:#e6db74">&#34;std&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">const</span> io_mode <span style="color:#f92672">=</span> .evented;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> main() <span style="color:#f92672">!</span><span style="color:#66d9ef">void</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> cpu<span style="color:#f92672">:</span> <span style="color:#66d9ef">u64</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">try</span> std.Thread.getCpuCount();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Allocate room for an async frame for every 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// logical cpu core
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">var</span> promises <span style="color:#f92672">=</span> <span style="color:#66d9ef">try</span> std.heap.page_allocator.alloc(@Frame(worker), cpu);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">defer</span> std.heap.page_allocator.free(promises);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Start a worker on every cpu
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">var</span> completion_token<span style="color:#f92672">:</span> <span style="color:#66d9ef">bool</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">false</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (cpu <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>) <span style="color:#f92672">:</span> (cpu <span style="color:#f92672">-=</span> <span style="color:#ae81ff">1</span>) {
</span></span><span style="display:flex;"><span>        promises[cpu <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> <span style="color:#66d9ef">async</span> worker(cpu, <span style="color:#f92672">&amp;</span>completion_token);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    std.debug.print(<span style="color:#e6db74">&#34;Working...</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, .{});
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Wait for a worker to find the solution
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> (promises) <span style="color:#f92672">|*</span>future<span style="color:#f92672">|</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">var</span> result <span style="color:#f92672">=</span> <span style="color:#66d9ef">await</span> future;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (result <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>            std.debug.print(<span style="color:#e6db74">&#34;The answer is {x}</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, .{result});
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> worker(seed<span style="color:#f92672">:</span> <span style="color:#66d9ef">u64</span>, completion_token<span style="color:#f92672">:</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">bool</span>) <span style="color:#66d9ef">u64</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Inform the event loop we&#39;re cpu bound. 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// This effectively puts a worker on every logical core.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    std.event.Loop.startCpuBoundOperation();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Seed the random number generator so each worker
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// look at different numbers
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">var</span> prng <span style="color:#f92672">=</span> std.rand.DefaultPrng.init(seed);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">const</span> random <span style="color:#f92672">=</span> prng.random();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (<span style="color:#66d9ef">true</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">var</span> attempt <span style="color:#f92672">=</span> random.int(<span style="color:#66d9ef">u64</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// We&#39;re looking for a number whose N lower bits 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// are zero. Feel free to change the constant to 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// make this take a longer or shorter amount of time.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (attempt <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">0xffffff</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// Tell other workers we&#39;re done
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            @atomicStore(<span style="color:#66d9ef">bool</span>, completion_token, <span style="color:#66d9ef">true</span>, std.builtin.AtomicOrder.Release);
</span></span><span style="display:flex;"><span>            std.debug.print(<span style="color:#e6db74">&#34;I found the answer!</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, .{});
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> attempt;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Check if another worker has solved it, in which
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// case we stop working on the problem.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (@atomicLoad(<span style="color:#66d9ef">bool</span>, completion_token, std.builtin.AtomicOrder.Acquire)) {
</span></span><span style="display:flex;"><span>            std.debug.print(<span style="color:#e6db74">&#34;Another worker won</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, .{});
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Run the program and observe all cpu cores get to work using <code>htop</code> or similar (you may have to adjust 0xffffff if it&rsquo;s too fast or too slow)</p>
<p><em>Edit: some clarifications thanks to Protty on Discord</em></p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
  </footer>
</article>
    </main>
     </body>

</html>
