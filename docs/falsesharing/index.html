<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Cache Me If You Can | cryptocode</title>
<meta name="keywords" content="">
<meta name="description" content="Why would adding a single keyword to a struct in Zig give a 30% performance increase, with far less variability? As it turns out, tightly packed data structures and field reorderings can cause surprising performance issues in multithreaded programs due to false sharing. Let&rsquo;s look at the numbers.">
<meta name="author" content="">
<link rel="canonical" href="https://cryptocode.github.io/blog/docs/falsesharing/">
<link crossorigin="anonymous" href="/blog/assets/css/stylesheet.4c59be9189121e04b02540f0db455c1b918d81a0572270ff1582a70e029b7c48.css" integrity="sha256-TFm&#43;kYkSHgSwJUDw20VcG5GNgaBXInD/FYKnDgKbfEg=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/blog/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js" integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG&#43;9vmJ0cTS&#43;ovo0FeA="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://cryptocode.github.io/blog/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://cryptocode.github.io/blog/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://cryptocode.github.io/blog/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://cryptocode.github.io/blog/apple-touch-icon.png">
<link rel="mask-icon" href="https://cryptocode.github.io/blog/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="Cache Me If You Can" />
<meta property="og:description" content="Why would adding a single keyword to a struct in Zig give a 30% performance increase, with far less variability? As it turns out, tightly packed data structures and field reorderings can cause surprising performance issues in multithreaded programs due to false sharing. Let&rsquo;s look at the numbers." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cryptocode.github.io/blog/docs/falsesharing/" /><meta property="article:section" content="docs" />
<meta property="article:published_time" content="2023-07-08T18:45:37+02:00" />
<meta property="article:modified_time" content="2023-07-08T18:45:37+02:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Cache Me If You Can"/>
<meta name="twitter:description" content="Why would adding a single keyword to a struct in Zig give a 30% performance increase, with far less variability? As it turns out, tightly packed data structures and field reorderings can cause surprising performance issues in multithreaded programs due to false sharing. Let&rsquo;s look at the numbers."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Docs",
      "item": "https://cryptocode.github.io/blog/docs/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Cache Me If You Can",
      "item": "https://cryptocode.github.io/blog/docs/falsesharing/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Cache Me If You Can",
  "name": "Cache Me If You Can",
  "description": "Why would adding a single keyword to a struct in Zig give a 30% performance increase, with far less variability? As it turns out, tightly packed data structures and field reorderings can cause surprising performance issues in multithreaded programs due to false sharing. Let\u0026rsquo;s look at the numbers.\n",
  "keywords": [
    
  ],
  "articleBody": "Why would adding a single keyword to a struct in Zig give a 30% performance increase, with far less variability? As it turns out, tightly packed data structures and field reorderings can cause surprising performance issues in multithreaded programs due to false sharing. Let’s look at the numbers.\nFalse sharing occurs when the data layout is at odds with the memory access pattern, namely multiple threads managing unrelated data that happens to fall on the same cache line.\nA cache line is the smallest unit of transfer between Lx caches and main memory, and thus also the unit of synchronization of coherence protocols such as MESI. When a thread on a core updates a memory location, the affected cache line is marked as dirty and other cores (logical or not) must invalidate their copy of the cache line.\nCache line invalidation is very expensive, and may additionally cause issues for applications that are sensitive to performance variability. When false sharing does happen, the actual impact depends on a thread’s affinity to core socket/hyperthreads, scheduling, and the number of threads.\nA cache line is typically 64 bytes, but this can vary depending on the CPU architecture. Tools such as lstopo is useful to determine the cache line size and the cache hierachy on your system.\nA little Zig surprise Take a look at this struct:\nconst Queue = struct { head_index: u64 = 0, padding: [128]u8 = undefined, tail_index: u64 = 0, }; Now imagine you have two threads updating head_index and tail_index.\nChanging the struct to the following makes the program run 30% faster on my Intel Core i9, and with an order of magnitude lower standard deviation:\nconst Queue = extern struct { head_index: u64 = 0, padding: [128]u8 = undefined, tail_index: u64 = 0, }; The difference? The extern keyword. This tells the compiler to adhere to the C ABI, which means the compiler will not reorder the fields.\nNote that we can not use a packed struct in this example as the padding type is not supported (In Zig, packed structs are just fancy integers)\nFor regular structs, Zig may reorder the fields to minimize padding, which is a good thing in general.\nHowever, by enforcing the ordering, the indended reason for padding causes head_index and tail_index to fall on different cache lines, and thus false sharing is avoided: The two threads can update their respective fields without invalidating each other’s cache lines.\nTo reduce the chance of false sharing, we must force a suitable field ordering, add padding fields or set alignment on specific fields.\nThe code Here’s a simple benchmark that demonstrates the issue:\nconst std = @import(\"std\"); blah blah blah The doNotOptimizeAway(i) boils down to asm volatile (\"\" :: [i] \"r\" (i),); on my machine, which is a compiler barrier that prevents the compiler from simply optimizing away the loop (which wouldn’t make for a useful benchmark)\nThe numbers The following tables shows the benchmark summary and 10 timings for the case where false sharing does not occur, and 10 timings for the case where false sharing does occur.\nWhile a larger number of samples were taken to verify the effect, the numbers below are representative.\nNot only is the average time for the false sharing case worse, the standard deviation is also an order of magnitude higher.\nNo false sharing False sharing mean 3.0299017825599996 4.738531733004999 stddev 0.011379971724662449 0.13044659161376454 median 3.02725268766 4.7289631684049995 min 3.01537040366 4.582206681904999 max 3.0460710066599996 5.081537872905 The actual runs:\nNo false sharing False sharing 3.04404566866 4.582206681904999 3.0200773766599998 4.732641409905 3.0460710066599996 5.081537872905 3.02459747266 4.680716246905 3.01537040366 4.750897377905 3.03074159466 4.733568547905 3.02830799766 4.678189750905 3.0449196536599996 4.725284926904999 3.02619737766 4.742324924905 3.0186892736599997 4.677949589904999 Hyperthreading adds a twist The timings above are with hyperthreading disabled. With hyperthreading enabled, the timings for the false sharing case are much more variable, but still consistently worse than the no false sharing case.\n",
  "wordCount" : "637",
  "inLanguage": "en",
  "datePublished": "2023-07-08T18:45:37+02:00",
  "dateModified": "2023-07-08T18:45:37+02:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://cryptocode.github.io/blog/docs/falsesharing/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "cryptocode",
    "logo": {
      "@type": "ImageObject",
      "url": "https://cryptocode.github.io/blog/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://cryptocode.github.io/blog/" accesskey="h" title="cryptocode (Alt + H)">cryptocode</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      Cache Me If You Can
    </h1>
    <div class="post-meta"><span title='2023-07-08 18:45:37 +0200 +0200'>July 8, 2023</span>

</div>
  </header> 
  <div class="post-content"><p>Why would adding a single keyword to a struct in Zig give a 30% performance increase, with far less variability? As it turns out, tightly packed data structures and field reorderings can cause surprising performance issues in multithreaded programs due to <em>false sharing</em>. Let&rsquo;s look at the numbers.</p>
<p>False sharing occurs when the data layout is at odds with the memory access pattern, namely multiple threads managing unrelated data that happens to fall on the same <em>cache line</em>.</p>
<p>A cache line is the smallest unit of transfer between Lx caches and main memory, and thus also the unit of synchronization of coherence protocols such as MESI. When a thread on a core updates a memory location, the affected cache line is marked as dirty and other cores (logical or not) must invalidate their copy of the cache line.</p>
<p>Cache line invalidation is very expensive, and may additionally cause issues for applications that are sensitive to performance variability. When false sharing does happen, the actual impact depends on a thread&rsquo;s affinity to core socket/hyperthreads, scheduling, and the number of threads.</p>
<p>A cache line is typically 64 bytes, but this can vary depending on the CPU architecture. Tools such as <code>lstopo</code> is useful to determine the cache line size and the cache hierachy on your system.</p>
<h3 id="a-little-zig-surprise">A little Zig surprise<a hidden class="anchor" aria-hidden="true" href="#a-little-zig-surprise">#</a></h3>
<p>Take a look at this struct:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-zig" data-lang="zig"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> Queue <span style="color:#f92672">=</span> <span style="color:#66d9ef">struct</span>  {
</span></span><span style="display:flex;"><span>    head_index<span style="color:#f92672">:</span> <span style="color:#66d9ef">u64</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>,
</span></span><span style="display:flex;"><span>    padding<span style="color:#f92672">:</span> [<span style="color:#ae81ff">128</span>]<span style="color:#66d9ef">u8</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">undefined</span>,
</span></span><span style="display:flex;"><span>    tail_index<span style="color:#f92672">:</span> <span style="color:#66d9ef">u64</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>,
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>Now imagine you have two threads updating <code>head_index</code> and <code>tail_index</code>.</p>
<p>Changing the struct to the following makes the program run 30% faster on my Intel Core i9, and with an <em>order of magnitude</em> lower standard deviation:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-zig" data-lang="zig"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> Queue <span style="color:#f92672">=</span> <span style="color:#66d9ef">extern</span> <span style="color:#66d9ef">struct</span>  {
</span></span><span style="display:flex;"><span>    head_index<span style="color:#f92672">:</span> <span style="color:#66d9ef">u64</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>,
</span></span><span style="display:flex;"><span>    padding<span style="color:#f92672">:</span> [<span style="color:#ae81ff">128</span>]<span style="color:#66d9ef">u8</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">undefined</span>,
</span></span><span style="display:flex;"><span>    tail_index<span style="color:#f92672">:</span> <span style="color:#66d9ef">u64</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>,
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>The difference? The <code>extern</code> keyword. This tells the compiler to adhere to the C ABI, which means the compiler will <em>not</em> reorder the fields.</p>
<p><em>Note that we can not use a</em> <code>packed struct</code> <em>in this example as the padding type is not supported (In Zig, packed structs are just fancy integers)</em></p>
<p>For regular structs, Zig may reorder the fields to <em>minimize padding</em>, which is a good thing in general.</p>
<p>However, by enforcing the ordering, the indended reason for padding causes <code>head_index</code> and <code>tail_index</code> to fall on different cache lines, and thus false sharing is avoided: The two threads can update their respective fields without invalidating each other&rsquo;s cache lines.</p>
<p>To reduce the chance of false sharing, we must force a suitable field ordering, add padding fields or set alignment on specific fields.</p>
<h3 id="the-code">The code<a hidden class="anchor" aria-hidden="true" href="#the-code">#</a></h3>
<p>Here&rsquo;s a simple benchmark that demonstrates the issue:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-zig" data-lang="zig"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> std <span style="color:#f92672">=</span> @import(<span style="color:#e6db74">&#34;std&#34;</span>);
</span></span><span style="display:flex;"><span>blah blah blah
</span></span></code></pre></div><p>The <code>doNotOptimizeAway(i)</code> boils down to <code>asm volatile (&quot;&quot; :: [i] &quot;r&quot; (i),);</code> on my machine, which is a compiler barrier that prevents the compiler from simply optimizing away the loop (which wouldn&rsquo;t make for a useful benchmark)</p>
<h3 id="the-numbers">The numbers<a hidden class="anchor" aria-hidden="true" href="#the-numbers">#</a></h3>
<p>The following tables shows the benchmark summary and 10 timings for the case where false sharing does not occur, and 10 timings for the case where false sharing does occur.</p>
<p>While a larger number of samples were taken to verify the effect, the numbers below are representative.</p>
<p>Not only is the average time for the false sharing case worse, the standard deviation is also an order of magnitude higher.</p>
<table>
<thead>
<tr>
<th></th>
<th>No false sharing</th>
<th>False sharing</th>
</tr>
</thead>
<tbody>
<tr>
<td>mean</td>
<td>3.0299017825599996</td>
<td>4.738531733004999</td>
</tr>
<tr>
<td>stddev</td>
<td>0.011379971724662449</td>
<td>0.13044659161376454</td>
</tr>
<tr>
<td>median</td>
<td>3.02725268766</td>
<td>4.7289631684049995</td>
</tr>
<tr>
<td>min</td>
<td>3.01537040366</td>
<td>4.582206681904999</td>
</tr>
<tr>
<td>max</td>
<td>3.0460710066599996</td>
<td>5.081537872905</td>
</tr>
</tbody>
</table>
<p>The actual runs:</p>
<table>
<thead>
<tr>
<th>No false sharing</th>
<th>False sharing</th>
</tr>
</thead>
<tbody>
<tr>
<td>3.04404566866</td>
<td>4.582206681904999</td>
</tr>
<tr>
<td>3.0200773766599998</td>
<td>4.732641409905</td>
</tr>
<tr>
<td>3.0460710066599996</td>
<td>5.081537872905</td>
</tr>
<tr>
<td>3.02459747266</td>
<td>4.680716246905</td>
</tr>
<tr>
<td>3.01537040366</td>
<td>4.750897377905</td>
</tr>
<tr>
<td>3.03074159466</td>
<td>4.733568547905</td>
</tr>
<tr>
<td>3.02830799766</td>
<td>4.678189750905</td>
</tr>
<tr>
<td>3.0449196536599996</td>
<td>4.725284926904999</td>
</tr>
<tr>
<td>3.02619737766</td>
<td>4.742324924905</td>
</tr>
<tr>
<td>3.0186892736599997</td>
<td>4.677949589904999</td>
</tr>
</tbody>
</table>
<h3 id="hyperthreading-adds-a-twist">Hyperthreading adds a twist<a hidden class="anchor" aria-hidden="true" href="#hyperthreading-adds-a-twist">#</a></h3>
<p>The timings above are with hyperthreading disabled. With hyperthreading enabled, the timings for the false sharing case are much more variable, but still consistently worse than the no false sharing case.</p>

  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
  </footer>
</article>
    </main>
     </body>

</html>
