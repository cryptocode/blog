<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Zig asserts are not C asserts |  ~/cryptocode</title>
<meta name="keywords" content="">
<meta name="description" content="I recently came across a piece of code in a Ziggit.dev post that gave me pause:
pub fn putOne(q: *@This(), io: Io, item: Elem) Cancelable!void { assert(try q.put(io, &amp;.{item}, 1) == 1); } pub fn getOne(q: *@This(), io: Io) Cancelable!Elem { var buf: [1]Elem = undefined; assert(try q.get(io, &amp;buf, 1) == 1); return buf[0]; } &hellip;which lead me to ask the following:
Just a quick side quest: Doesn’t the assert here risk put and get calls being optimized away?">
<meta name="author" content="">
<link rel="canonical" href="https://cryptocode.github.io/blog/docs/assert/">
<link crossorigin="anonymous" href="/blog/assets/css/stylesheet.31670b680bf0c33daf591b5847a304d489f83cb2bc3d2971d5f25009e51af4ca.css" integrity="sha256-MWcLaAvwwz2vWRtYR6ME1In4PLK8PSlx1fJQCeUa9Mo=" rel="preload stylesheet" as="style"><link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Gentium+Plus:ital,wght@0,400;0,700;1,400;1,700&display=swap" rel="stylesheet">
<link rel="icon" href="https://cryptocode.github.io/blog/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://cryptocode.github.io/blog/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://cryptocode.github.io/blog/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://cryptocode.github.io/blog/apple-touch-icon.png">
<link rel="mask-icon" href="https://cryptocode.github.io/blog/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript><meta property="og:title" content="Zig asserts are not C asserts" />
<meta property="og:description" content="I recently came across a piece of code in a Ziggit.dev post that gave me pause:
pub fn putOne(q: *@This(), io: Io, item: Elem) Cancelable!void { assert(try q.put(io, &amp;.{item}, 1) == 1); } pub fn getOne(q: *@This(), io: Io) Cancelable!Elem { var buf: [1]Elem = undefined; assert(try q.get(io, &amp;buf, 1) == 1); return buf[0]; } &hellip;which lead me to ask the following:
Just a quick side quest: Doesn’t the assert here risk put and get calls being optimized away?" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cryptocode.github.io/blog/docs/assert/" />
<meta property="og:image" content="https://cryptocode.github.io/blog/images/mondrian.png" />
<meta property="article:section" content="docs" />
<meta property="article:published_time" content="2025-07-22T20:32:37+02:00" />
<meta property="article:modified_time" content="2025-07-22T20:32:37+02:00" />

<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:image" content="https://cryptocode.github.io/blog/images/mondrian.png" />
<meta name="twitter:title" content="Zig asserts are not C asserts"/>
<meta name="twitter:description" content="I recently came across a piece of code in a Ziggit.dev post that gave me pause:
pub fn putOne(q: *@This(), io: Io, item: Elem) Cancelable!void { assert(try q.put(io, &amp;.{item}, 1) == 1); } pub fn getOne(q: *@This(), io: Io) Cancelable!Elem { var buf: [1]Elem = undefined; assert(try q.get(io, &amp;buf, 1) == 1); return buf[0]; } &hellip;which lead me to ask the following:
Just a quick side quest: Doesn’t the assert here risk put and get calls being optimized away?"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Docs",
      "item": "https://cryptocode.github.io/blog/docs/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Zig asserts are not C asserts",
      "item": "https://cryptocode.github.io/blog/docs/assert/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Zig asserts are not C asserts",
  "name": "Zig asserts are not C asserts",
  "description": "I recently came across a piece of code in a Ziggit.dev post that gave me pause:\npub fn putOne(q: *@This(), io: Io, item: Elem) Cancelable!void { assert(try q.put(io, \u0026amp;.{item}, 1) == 1); } pub fn getOne(q: *@This(), io: Io) Cancelable!Elem { var buf: [1]Elem = undefined; assert(try q.get(io, \u0026amp;buf, 1) == 1); return buf[0]; } \u0026hellip;which lead me to ask the following:\nJust a quick side quest: Doesn’t the assert here risk put and get calls being optimized away?",
  "keywords": [
    
  ],
  "articleBody": "I recently came across a piece of code in a Ziggit.dev post that gave me pause:\npub fn putOne(q: *@This(), io: Io, item: Elem) Cancelable!void { assert(try q.put(io, \u0026.{item}, 1) == 1); } pub fn getOne(q: *@This(), io: Io) Cancelable!Elem { var buf: [1]Elem = undefined; assert(try q.get(io, \u0026buf, 1) == 1); return buf[0]; } …which lead me to ask the following:\nJust a quick side quest: Doesn’t the assert here risk put and get calls being optimized away? If not I think I might have misunderstood std.debug.assert’s doc comment and could use some education.\nSince assert is a regular function, the argument is evaluated (and is indeed in debug/safe builds), but since the expression is assumed to be true (otherwise unreachable) it seems like the whole expression is allowed to be removed\nIs there a difference whether the expression is fallible or not, or is deemed to have side effects?\nThe nice thing about Ziggit is that core team members frequently chimes in with their expertise, and that was the case here as well. So I figured I’d try to summarize my understanding of Zig assertions based on those posts.\nThe short answer to my question is: no, the put and get calls will definitely not get optimized away. We’ll see why in a bit.\nstd.debug.assert and unreachable If you’ve ever hit an assertion in Zig, then you have also looked at the implementation of std.debug.assert since it appears in the panic trace:\nthread 33583038 panic: reached unreachable code lib/std/debug.zig:550:14: 0x10495bc93 in assert (sideeffects) if (!ok) unreachable; // assertion failure That’s all assert does: if (!ok) unreachable;\nIf unreachable is hit in safe modes, then… well, you’ve seen the panic trace. Very helpful.\nIn optimizing modes, unreachable becomes a promise that control flow will not reach this point at all. Also very helpful: faster code!\nHere’s the doc comment on assert that helped myself and some others get confused, despite the comment being 100% verifiably correct:\nIn ReleaseFast and ReleaseSmall modes, calls to this function are optimized away, and in fact the optimizer is able to use the assertion in its heuristics.\nOn closer inspection, this is just what the language reference entry on unreachable promise us. No more, no less.\nThis is very different from C’s assert which nukes the whole thing through macros and preprocessor directives. It’s a similar story in many other languages. They have special constructs for asserts. Zig does not; std.debug.assert is a plain old function for which no special treatment is given.\nThe idea that if (!ok) unreachable; somehow magically wires up the optimizer to always delete “the whole thing” is wrong.\nDoes this mean asserts can be expensive even in ReleaseFast mode? Yes, because while the call to assert is gone, the LLVM optimizer that’s supposed to remove dead code isn’t always able to do so. Bugs, limitations and side effects. An expensive check passed as an argument to assert may remain. Simple expressions like data.len \u003e 0 will almost certainly be optimized out, but it’s less clear for anything non-trivial.\nI shared an example in the Ziggit thread where dead code removal does not happen. Here’s an improved version by TibboddiT:\nconst std = @import(\"std\"); fn check(val: []u8) bool { var sum: usize = 0; for (0..val.len * 500_000_000) |v| { sum += val[v % val.len]; } return sum == 6874500000000; } pub fn main() void { var prng: std.Random.DefaultPrng = .init(12); const rand = prng.random(); var buf: [100]u8 = undefined; rand.bytes(\u0026buf); std.debug.assert(check(\u0026buf)); } Compile and run this under ReleaseFast on Zig 0.14.x and you’ll see that the program is busy for a good while. The core team believe this is a missed optimization in LLVM.\nIf profiling shows that an assertion is expensive, or you’re just not confident it will be fully elided, you can do something like this:\nif (std.debug.runtime_safety) std.debug.assert(check(\u0026buf));\n…or check against build modes when that makes more sense.\nWhen the optimizer will definitely not remove code Now back to the original question, which is about the opposite of trying to get rid of dead code. We want to keep code.\nThere are many reasons why code will never be removed by a correctly implemented optimizer. One of them is the presence of side effects. Another example is when writes to memory must be observable when that memory is later read. Basically, the optimizer’s rule is that code removal must not lead to correctness bugs.\nThe put call in assert(try q.put(io, \u0026.{item}, 1) == 1); have side effects and depends on memory coherence as there’s a get call elsewhere. We’re all good.\nBy the way, Andrew Kelley shared Zig’s concrete list of side effects:\nloading through a volatile pointer storing through a volatile pointer inline assembly with volatile keyword atomics with volatile pointers calling an extern function @panic, @trap, @breakpoint unreachable in safe optimization modes (equivalent to @panic) There isn’t really anything to worry about here beyond perhaps LLVM optimization bugs.\nConclusion: std.debug.assert(expr) is just if (!expr) unreachable where unreachable yields a helpful trace in safe build modes, and provides the optimizer with useful information in unsafe builds The optimizer may or may not be able to optimize away expr The optimizer will never optimize away expr if doing so would lead to correctness issues ",
  "wordCount" : "878",
  "inLanguage": "en",
  "image": "https://cryptocode.github.io/blog/images/mondrian.png","datePublished": "2025-07-22T20:32:37+02:00",
  "dateModified": "2025-07-22T20:32:37+02:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://cryptocode.github.io/blog/docs/assert/"
  },
  "publisher": {
    "@type": "Organization",
    "name": " ~/cryptocode",
    "logo": {
      "@type": "ImageObject",
      "url": "https://cryptocode.github.io/blog/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://cryptocode.github.io/blog/" accesskey="h" title=" ~/cryptocode (Alt + H)">
                <img src="https://cryptocode.github.io/blog/images/mondrian.png" alt="" aria-label="logo"
                    height="35"> ~/cryptocode</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      Zig asserts are not C asserts
    </h1>
    <div class="post-meta"><span title='2025-07-22 20:32:37 +0200 +0200'>July 22, 2025</span>

</div>
  </header> 
  <div class="post-content"><p>I recently came across a piece of code in a Ziggit.dev post that gave me pause:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-zig" data-lang="zig"><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> putOne(q<span style="color:#f92672">:</span> <span style="color:#f92672">*</span>@This(), io<span style="color:#f92672">:</span> Io, item<span style="color:#f92672">:</span> Elem) Cancelable<span style="color:#f92672">!</span><span style="color:#66d9ef">void</span> {
</span></span><span style="display:flex;"><span>    assert(<span style="color:#66d9ef">try</span> q.put(io, <span style="color:#f92672">&amp;</span>.{item}, <span style="color:#ae81ff">1</span>) <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> getOne(q<span style="color:#f92672">:</span> <span style="color:#f92672">*</span>@This(), io<span style="color:#f92672">:</span> Io) Cancelable<span style="color:#f92672">!</span>Elem {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> buf<span style="color:#f92672">:</span> [<span style="color:#ae81ff">1</span>]Elem <span style="color:#f92672">=</span> <span style="color:#66d9ef">undefined</span>;
</span></span><span style="display:flex;"><span>    assert(<span style="color:#66d9ef">try</span> q.get(io, <span style="color:#f92672">&amp;</span>buf, <span style="color:#ae81ff">1</span>) <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> buf[<span style="color:#ae81ff">0</span>];
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>&hellip;which lead me to ask the following:</p>
<blockquote>
<p>Just a quick side quest: Doesn’t the assert here risk <code>put</code> and <code>get</code> calls being optimized away? If not I think I might have misunderstood std.debug.assert’s doc comment and could use some education.</p>
<p>Since assert is a regular function, the argument is evaluated (and is indeed in debug/safe builds), but since the expression is assumed to be true (otherwise unreachable) it seems like the whole expression is allowed to be removed</p>
<p>Is there a difference whether the expression is fallible or not, or is deemed to have side effects?</p>
</blockquote>
<p>The nice thing about <a href="https://ziggit.dev">Ziggit</a> is that core team members frequently chimes in with their expertise, and that was the case here as well. So I figured I&rsquo;d try to summarize my understanding of Zig assertions based on those posts.</p>
<p>The short answer to my question is: no, the <em>put</em> and <em>get</em> calls will definitely <em>not</em> get optimized away. We&rsquo;ll see why in a bit.</p>
<h2 id="stddebugassert-and-unreachable">std.debug.assert and unreachable<a hidden class="anchor" aria-hidden="true" href="#stddebugassert-and-unreachable">#</a></h2>
<p>If you&rsquo;ve ever hit an assertion in Zig, then you have also looked at the implementation of <code>std.debug.assert</code> since it appears in the panic trace:</p>
<pre tabindex="0"><code>thread 33583038 panic: reached unreachable code

lib/std/debug.zig:550:14: 0x10495bc93 in assert (sideeffects)

if (!ok) unreachable; // assertion failure
</code></pre><p>That&rsquo;s all assert does: <code>if (!ok) unreachable;</code></p>
<ul>
<li>
<p>If <em>unreachable</em> is hit in safe modes, then&hellip; well, you&rsquo;ve seen the panic trace. Very helpful.</p>
</li>
<li>
<p>In optimizing modes, <em>unreachable</em> becomes a promise that control flow will not reach this point at all. Also very helpful: faster code!</p>
</li>
</ul>
<p>Here&rsquo;s the doc comment on <code>assert</code> that helped myself and some others get confused, despite the comment being 100% verifiably correct:</p>
<blockquote>
<p>In ReleaseFast and ReleaseSmall modes, calls to this function are optimized
away, and in fact the optimizer is able to use the assertion in its
heuristics.</p>
</blockquote>
<p>On closer inspection, this is just what the language reference entry on <code>unreachable</code> promise us. No more, no less.</p>
<p>This is very different from C&rsquo;s assert which nukes the whole thing through macros and preprocessor directives. It&rsquo;s a similar story in many other languages. They have special constructs for asserts. Zig does not; <code>std.debug.assert</code> is a plain old function for which no special treatment is given.</p>
<p>The idea that <code>if (!ok) unreachable;</code> somehow magically wires up the optimizer to always delete &ldquo;the whole thing&rdquo; is wrong.</p>
<h2 id="does-this-mean-asserts-can-be-expensive-even-in-releasefast-mode">Does this mean asserts can be expensive even in ReleaseFast mode?<a hidden class="anchor" aria-hidden="true" href="#does-this-mean-asserts-can-be-expensive-even-in-releasefast-mode">#</a></h2>
<p>Yes, because while the call to assert is gone, the LLVM optimizer that&rsquo;s supposed to remove dead code isn&rsquo;t always able to do so. Bugs, limitations and side effects. An expensive check passed as an argument to assert <em>may</em> remain. Simple expressions like <code>data.len &gt; 0</code> will almost certainly be
optimized out, but it&rsquo;s less clear for anything non-trivial.</p>
<p>I shared an example in the Ziggit thread where dead code removal does <em>not</em> happen. Here&rsquo;s an improved version by <em>TibboddiT</em>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-zig" data-lang="zig"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> std <span style="color:#f92672">=</span> @import(<span style="color:#e6db74">&#34;std&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> check(val<span style="color:#f92672">:</span> []<span style="color:#66d9ef">u8</span>) <span style="color:#66d9ef">bool</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> sum<span style="color:#f92672">:</span> <span style="color:#66d9ef">usize</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#ae81ff">0</span>..val.len <span style="color:#f92672">*</span> <span style="color:#ae81ff">500_000_000</span>) <span style="color:#f92672">|</span>v<span style="color:#f92672">|</span> {
</span></span><span style="display:flex;"><span>        sum <span style="color:#f92672">+=</span> val[v <span style="color:#f92672">%</span> val.len];
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> sum <span style="color:#f92672">==</span> <span style="color:#ae81ff">6874500000000</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> main() <span style="color:#66d9ef">void</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> prng<span style="color:#f92672">:</span> std.Random.DefaultPrng <span style="color:#f92672">=</span> .init(<span style="color:#ae81ff">12</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">const</span> rand <span style="color:#f92672">=</span> prng.random();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> buf<span style="color:#f92672">:</span> [<span style="color:#ae81ff">100</span>]<span style="color:#66d9ef">u8</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">undefined</span>;
</span></span><span style="display:flex;"><span>    rand.bytes(<span style="color:#f92672">&amp;</span>buf);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    std.debug.assert(check(<span style="color:#f92672">&amp;</span>buf));
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Compile and run this under ReleaseFast on Zig 0.14.x and you&rsquo;ll see that the program is busy for a good while. The core team believe this is a missed optimization in LLVM.</p>
<p>If profiling shows that an assertion is expensive, or you&rsquo;re just not confident it will be fully elided, you can do something like this:</p>
<p><code>if (std.debug.runtime_safety) std.debug.assert(check(&amp;buf));</code></p>
<p>&hellip;or check against build modes when that makes more sense.</p>
<h3 id="when-the-optimizer-will-definitely-not-remove-code">When the optimizer will definitely not remove code<a hidden class="anchor" aria-hidden="true" href="#when-the-optimizer-will-definitely-not-remove-code">#</a></h3>
<p>Now back to the original question, which is about the opposite of trying to get rid of dead code. We want to <em>keep</em> code.</p>
<p>There are many reasons why code will never be removed by a correctly implemented optimizer. One of them is the presence of side effects. Another example is when writes to memory must be observable when that memory is later read. Basically, the optimizer&rsquo;s rule is that code removal must not lead to correctness bugs.</p>
<p>The <em>put</em> call in <code>assert(try q.put(io, &amp;.{item}, 1) == 1);</code> have side effects <em>and</em> depends on memory coherence as there&rsquo;s a <em>get</em> call elsewhere. We&rsquo;re all good.</p>
<p>By the way, Andrew Kelley shared Zig&rsquo;s concrete list of side effects:</p>
<blockquote>
<ul>
<li>loading through a volatile pointer</li>
<li>storing through a volatile pointer</li>
<li>inline assembly with volatile keyword</li>
<li>atomics with volatile pointers</li>
<li>calling an extern function</li>
<li>@panic, @trap, @breakpoint</li>
<li>unreachable in safe optimization modes (equivalent to @panic)</li>
</ul>
</blockquote>
<p>There isn&rsquo;t really anything to worry about here beyond perhaps LLVM optimization bugs.</p>
<h1 id="conclusion">Conclusion:<a hidden class="anchor" aria-hidden="true" href="#conclusion">#</a></h1>
<ul>
<li><code>std.debug.assert(expr)</code> is just <code>if (!expr) unreachable</code> where <em>unreachable</em> yields a helpful trace in safe build modes, and provides the optimizer with useful information in unsafe builds</li>
<li>The optimizer may or may not be able to optimize away <code>expr</code></li>
<li>The optimizer will never optimize away <code>expr</code> if doing so would lead to correctness issues</li>
</ul>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
  </footer>
</article>
    </main>
     </body>

</html>
