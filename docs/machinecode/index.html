<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Embedding machine code in Zig instead of using inline assembly |  ~/cryptocode</title>
<meta name="keywords" content="">
<meta name="description" content="Linux and macOS Rosetta notes Assembling Calling from Zig A larger example with fast memcpy and syscalls Zig supports inline assembly, which is useful when:
Writing an operating system, which requires direct access to special CPU registers and controllers Implementing syscalls in a standard library Accessing microcontroller features on an embedded system Handwriting a performance-critical hot-path function where the optimizer isn&rsquo;t up to the task This post explores an alternative: write the assembly in separate files, run your favorite assembler, and then embed the resulting machine code using @embedFile.">
<meta name="author" content="">
<link rel="canonical" href="https://cryptocode.github.io/blog/docs/machinecode/">
<link crossorigin="anonymous" href="/blog/assets/css/stylesheet.31670b680bf0c33daf591b5847a304d489f83cb2bc3d2971d5f25009e51af4ca.css" integrity="sha256-MWcLaAvwwz2vWRtYR6ME1In4PLK8PSlx1fJQCeUa9Mo=" rel="preload stylesheet" as="style"><link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Gentium+Plus:ital,wght@0,400;0,700;1,400;1,700&display=swap" rel="stylesheet">
<link rel="icon" href="https://cryptocode.github.io/blog/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://cryptocode.github.io/blog/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://cryptocode.github.io/blog/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://cryptocode.github.io/blog/apple-touch-icon.png">
<link rel="mask-icon" href="https://cryptocode.github.io/blog/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript><meta property="og:title" content="Embedding machine code in Zig instead of using inline assembly" />
<meta property="og:description" content="Linux and macOS Rosetta notes Assembling Calling from Zig A larger example with fast memcpy and syscalls Zig supports inline assembly, which is useful when:
Writing an operating system, which requires direct access to special CPU registers and controllers Implementing syscalls in a standard library Accessing microcontroller features on an embedded system Handwriting a performance-critical hot-path function where the optimizer isn&rsquo;t up to the task This post explores an alternative: write the assembly in separate files, run your favorite assembler, and then embed the resulting machine code using @embedFile." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cryptocode.github.io/blog/docs/machinecode/" />
<meta property="og:image" content="https://cryptocode.github.io/blog/images/mondrian.png" />
<meta property="article:section" content="docs" />
<meta property="article:published_time" content="2023-07-29T12:01:51+02:00" />
<meta property="article:modified_time" content="2023-07-29T12:01:51+02:00" />

<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:image" content="https://cryptocode.github.io/blog/images/mondrian.png" />
<meta name="twitter:title" content="Embedding machine code in Zig instead of using inline assembly"/>
<meta name="twitter:description" content="Linux and macOS Rosetta notes Assembling Calling from Zig A larger example with fast memcpy and syscalls Zig supports inline assembly, which is useful when:
Writing an operating system, which requires direct access to special CPU registers and controllers Implementing syscalls in a standard library Accessing microcontroller features on an embedded system Handwriting a performance-critical hot-path function where the optimizer isn&rsquo;t up to the task This post explores an alternative: write the assembly in separate files, run your favorite assembler, and then embed the resulting machine code using @embedFile."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Docs",
      "item": "https://cryptocode.github.io/blog/docs/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Embedding machine code in Zig instead of using inline assembly",
      "item": "https://cryptocode.github.io/blog/docs/machinecode/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Embedding machine code in Zig instead of using inline assembly",
  "name": "Embedding machine code in Zig instead of using inline assembly",
  "description": "Linux and macOS Rosetta notes Assembling Calling from Zig A larger example with fast memcpy and syscalls Zig supports inline assembly, which is useful when:\nWriting an operating system, which requires direct access to special CPU registers and controllers Implementing syscalls in a standard library Accessing microcontroller features on an embedded system Handwriting a performance-critical hot-path function where the optimizer isn\u0026rsquo;t up to the task This post explores an alternative: write the assembly in separate files, run your favorite assembler, and then embed the resulting machine code using @embedFile.",
  "keywords": [
    
  ],
  "articleBody": " Linux and macOS Rosetta notes Assembling Calling from Zig A larger example with fast memcpy and syscalls Zig supports inline assembly, which is useful when:\nWriting an operating system, which requires direct access to special CPU registers and controllers Implementing syscalls in a standard library Accessing microcontroller features on an embedded system Handwriting a performance-critical hot-path function where the optimizer isn’t up to the task This post explores an alternative: write the assembly in separate files, run your favorite assembler, and then embed the resulting machine code using @embedFile. Running the assembler can obviously be automated from the build script.\nLinux and macOS Rosetta notes The code is tested on macOS, but also works with minor modifications on Linux (primarily the syscall number)\nSince the code here is x86_64, you can do the following on aarch64 macs to use Rosetta translation:\narch -x86_64 /bin/zsh --login zig build-exe -target x86_64-macos asm.zig ./asm Embedding machine code like this has very niche use cases vs. just linking an object file, but it’s a fun excercise.\nAssembling We’ll be using NASM to assemble the code, which allows us to emit raw machine code without any additional metadata.\nBelow is a simple snippet that adds two 64-bit numbers and returns the result:\n[BITS 64] mov rax, rdi add rax, rsi ret There’s no function prologue and epilogue - we’re not using the stack, so there’s no need for the overhead. There isn’t even a label naming the function.\nHowever, as far as the System V AMD64 ABI is concerned, this is a function, and we’ll be able to call it from Zig. Given the ABI calling convention, we know that the first argument is passed in rdi and the second in rsi, and we know that we should put the result in rax. The BITS 64 directive tells NASM to produce 64-bit machine code.\nLet’s assemble it:\nnasm -f bin -o asm-add.bin asm-add.s Thanks to -f bin, this will produce a file called asm-add.bin containing the raw machine code, with no metadata like headers and sections. Just raw machine code for each instruction in the assembly file.\nLet’s disassemble it to verify that claim:\nndisasm -b 64 asm-add.bin This will output the same instructions as in the assembly file:\nhexdump -C asm-add.bin 00000000 48 89 f8 48 01 f0 c3 That’s 7 bytes of machine code to add two numbers:\n; 0x48 is the REX prefix to indicate 64-bit operands ; 0x89 is the MOV instruction ; 0xf8 is the MOD R/M byte to specify the source and destination registers 48 89 f8: mov rax, rdi ; 0x48 is the REX prefix ; 0x01 is the ADD instruction ; 0xf0 is the MOD R/M byte to specify operand registers 48 01 f0: add rax, rsi ; 0xc3 is simply the RET instruction. It pops the return address from the stack and jumps to it ; The return address is placed there by the CALL instruction that Zig generates. c3: ret Calling from Zig Next, let’s call the add function from Zig.\nThe process is roughly as follows:\nAllocate a page of memory Write the machine code to the page. The machine code is loaded at compile time with @embedFile Mark the page as readable and executable using mprotect Cast the address of the buffer to a function pointer Call the function asm.zig\nconst std = @import(\"std\"); pub fn main() !void { const code = try std.heap.page_allocator.alignedAlloc(u8, @intCast(std.heap.pageSize()), std.heap.pageSize()); defer { // In order to deallocate, we have to make the page writable again _ = std.c.mprotect(@ptrCast(code), std.heap.pageSize(), std.c.PROT.WRITE); std.heap.page_allocator.free(code); } // Wrap the code page in a buffer stream and write the machine code to it var buf = std.io.fixedBufferStream(code); _ = try buf.write(@embedFile(\"asm-add.bin\")); _ = std.c.mprotect(@ptrCast(code), std.heap.pageSize(), std.c.PROT.READ | std.c.PROT.EXEC); // Make a Zig function pointer for adding two u64s and returning the result const add: *const fn (a: u64, b: u64) callconv(.C) u64 = @ptrCast(code); // Call the machine code through the function pointer // This will put the arguments into rdi and rsi, and return the result in rax const res = add(1, 2); std.debug.print(\"Res = {d}\\n\", .{res}); } Let’s run it:\nzig run asm.zig Res = 3 The structure is pretty nice: all the assembly code is in a separate file, and we can call it from Zig with no overhead beyond using registers for arguments, according to a specific calling convention.\nIf multiple CPU architectures are supported, the correct machine code file can be selected at compile time, typically by switching on builtin.cpu.arch\nLet’s take a quick look at what Zig generates for the add(1,2) call:\nmov rax, qword ptr [rbp - 96] mov edi, 1 mov esi, 2 call rax The first line puts the pointer to the add function into rax. The next two lines put the arguments into edi and esi, and the last line calls the function that was loaded into rax. Note that edi/esi are the 32-bit lower halves of rdi/rsi - the upper halves are zeroed out, and thus reading rdi/rsi will work as expected in the add implementation.\nA larger example with fast memcpy and syscalls Here’s an expanded version of the example, with two more functions: an AVX based memcpy, and an example of using syscalls to print a string to stdout.\nasm.zig\nconst std = @import(\"std\"); pub fn main() !void { const code = try std.heap.page_allocator.alignedAlloc(u8, @intCast(std.heap.pageSize()), std.heap.pageSize()); defer { // In order to deallocate, we have to make the page writable again _ = std.c.mprotect(@ptrCast(code), std.heap.pageSize(), std.c.PROT.WRITE); std.heap.page_allocator.free(code); } // Wrap the code page in a buffer stream and write the machine code to it var buf = std.io.fixedBufferStream(code); _ = try buf.write(@embedFile(\"asm-add.bin\")); _ = std.c.mprotect(@ptrCast(code), std.heap.pageSize(), std.c.PROT.READ | std.c.PROT.EXEC); // Make a Zig function pointer for adding two u64s and returning the result const add: *const fn (a: u64, b: u64) callconv(.C) u64 = @ptrCast(code); // Call the machine code through the function pointer const res = add(1, 2); std.debug.print(\"Res = {d}\\n\", .{res}); // Fast memcpy _ = std.c.mprotect(@ptrCast(code), std.heap.pageSize(), std.c.PROT.WRITE); try buf.seekTo(0); _ = try buf.write(@embedFile(\"asm-opt-memcpy.bin\")); _ = std.c.mprotect(@ptrCast(code), std.heap.pageSize(), std.c.PROT.READ | std.c.PROT.EXEC); // This memcpy requires the destination and source to be aligned to 32 bytes, and len to be a multiple of 64 bytes const fast_memcpy: *const fn (dst: u64, src: u64, len: u64) callconv(.C) ?[*]const u8 = @ptrCast(code); const dst = try std.heap.page_allocator.alignedAlloc(u8, 32, 64); const src = try std.heap.page_allocator.alignedAlloc(u8, 32, 64); const test_bytes = \"0123456789012345678901234567890123456789012345678901234567891234\"; @memcpy(src, test_bytes); _ = fast_memcpy(@intFromPtr(dst.ptr), @intFromPtr(src.ptr), 64); if (std.mem.eql(u8, test_bytes, dst)) { std.debug.print(\"fast_memcpy works!\\n\", .{}); } else { std.debug.print(\"fast_memcpy failed!\\n\", .{}); } try std.testing.expectEqualStrings(test_bytes, dst); // Next machine code file writes a message to stdout _ = std.c.mprotect(@ptrCast(code), std.heap.pageSize(), std.c.PROT.WRITE); try buf.seekTo(0); _ = try buf.write(@embedFile(\"asm-syscall.bin\")); _ = std.c.mprotect(@ptrCast(code), std.heap.pageSize(), std.c.PROT.READ | std.c.PROT.EXEC); const hello_world: *const fn (msg: ?[*:0]const u8, len: u64) callconv(.C) void = @ptrCast(code); hello_world(\"Hello, world!!!\\n\", 16); } Below are the two new assembly files.\nasm-opt-memcpy.s\nIn this case, we do need the function prologue and epilogue, because we’re using the stack to store the arguments and local variables.\nThis source is based on a disassembly on Compiler Explorer.\n[BITS 64] fast_memcpy: push rbp mov rbp, rsp and rsp, -32 sub rsp, 256 mov qword [rsp + 104], rdi mov qword [rsp + 96], rsi mov qword [rsp + 88], rdx mov qword [rsp + 80], 64 .LBB1_1: cmp qword [rsp + 88], 0 je .LBB1_3 mov rax, qword [rsp + 96] mov qword [rsp + 120], rax mov rax, qword [rsp + 120] vmovdqa ymm0, [rax] vmovdqa [rsp + 32], ymm0 mov rax, qword [rsp + 96] add rax, 32 mov qword [rsp + 112], rax mov rax, qword [rsp + 112] vmovdqa ymm0, [rax] vmovdqa [rsp], ymm0 mov rax, qword [rsp + 104] vmovdqa ymm0, [rsp + 32] mov qword [rsp + 232], rax vmovdqa [rsp + 192], ymm0 vmovdqa ymm0, [rsp + 192] mov rax, qword [rsp + 232] vmovntdq [rax], ymm0 mov rax, qword [rsp + 104] add rax, 32 vmovdqa ymm0, [rsp] mov qword [rsp + 184], rax vmovdqa [rsp + 128], ymm0 vmovdqa ymm0, [rsp + 128] mov rax, qword [rsp + 184] vmovntdq [rax], ymm0 mov rcx, qword [rsp + 80] mov rax, qword [rsp + 88] sub rax, rcx mov qword [rsp + 88], rax mov rax, qword [rsp + 80] add rax, qword [rsp + 96] mov qword [rsp + 96], rax mov rax, qword [rsp + 80] add rax, qword [rsp + 104] mov qword [rsp + 104], rax jmp .LBB1_1 .LBB1_3: mov rsp, rbp pop rbp vzeroupper ret asm-syscall.s\n[BITS 64] ; set up syscall arguments mov rdx, rsi mov rsi, rdi ; pick the write syscall on macOS mov rax, 0x2000004 ; stdout mov rdi, 1 ; invoke syscall zig run asm.zig Res = 3 fast_memcpy works! Hello, world!!! Edited July 2025. Code examples now compile with Zig 0.14.1. Added notes about using Rosetta on macOS.\n",
  "wordCount" : "1481",
  "inLanguage": "en",
  "image": "https://cryptocode.github.io/blog/images/mondrian.png","datePublished": "2023-07-29T12:01:51+02:00",
  "dateModified": "2023-07-29T12:01:51+02:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://cryptocode.github.io/blog/docs/machinecode/"
  },
  "publisher": {
    "@type": "Organization",
    "name": " ~/cryptocode",
    "logo": {
      "@type": "ImageObject",
      "url": "https://cryptocode.github.io/blog/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://cryptocode.github.io/blog/" accesskey="h" title=" ~/cryptocode (Alt + H)">
                <img src="https://cryptocode.github.io/blog/images/mondrian.png" alt="" aria-label="logo"
                    height="35"> ~/cryptocode</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      Embedding machine code in Zig instead of using inline assembly
    </h1>
    <div class="post-meta"><span title='2023-07-29 12:01:51 +0200 +0200'>July 29, 2023</span>

</div>
  </header> 
  <div class="post-content"><div style="font-size: small;">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#linux-and-macos-rosetta-notes">Linux and macOS Rosetta notes</a></li>
    <li><a href="#assembling">Assembling</a></li>
    <li><a href="#calling-from-zig">Calling from Zig</a></li>
    <li><a href="#a-larger-example-with-fast-memcpy-and-syscalls">A larger example with fast memcpy and syscalls</a></li>
  </ul>
</nav>
</div>
<p>Zig supports inline assembly, which is useful when:</p>
<ul>
<li>Writing an operating system, which requires direct access to special CPU registers and controllers</li>
<li>Implementing syscalls in a standard library</li>
<li>Accessing microcontroller features on an embedded system</li>
<li>Handwriting a performance-critical hot-path function where the optimizer isn&rsquo;t up to the task</li>
</ul>
<p>This post explores an alternative: write the assembly in separate files, run your favorite assembler, and then embed the resulting machine code using <code>@embedFile</code>. Running the assembler can obviously be automated from the build script.</p>
<h2 id="linux-and-macos-rosetta-notes">Linux and macOS Rosetta notes<a hidden class="anchor" aria-hidden="true" href="#linux-and-macos-rosetta-notes">#</a></h2>
<p>The code is tested on macOS, but also works with minor modifications on Linux (primarily the syscall number)</p>
<p>Since the code here is x86_64, you can do the following on aarch64 macs to use Rosetta translation:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>arch -x86_64 /bin/zsh --login
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>zig build-exe -target x86_64-macos asm.zig
</span></span><span style="display:flex;"><span>./asm
</span></span></code></pre></div><p>Embedding machine code like this has very niche use cases vs. just linking an object file, but it&rsquo;s a fun excercise.</p>
<h2 id="assembling">Assembling<a hidden class="anchor" aria-hidden="true" href="#assembling">#</a></h2>
<p>We&rsquo;ll be using NASM to assemble the code, which allows us to emit raw machine code without any additional metadata.</p>
<p>Below is a simple snippet that adds two 64-bit numbers and returns the result:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-as" data-lang="as"><span style="display:flex;"><span>[<span style="color:#a6e22e">BITS</span> <span style="color:#ae81ff">64</span>]
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">mov</span> <span style="color:#a6e22e">rax</span><span style="color:#f92672">,</span> <span style="color:#a6e22e">rdi</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">add</span> <span style="color:#a6e22e">rax</span><span style="color:#f92672">,</span> <span style="color:#a6e22e">rsi</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">ret</span>
</span></span></code></pre></div><p>There&rsquo;s no function prologue and epilogue - we&rsquo;re not using the stack, so there&rsquo;s no need for the overhead. There isn&rsquo;t even a label naming the function.</p>
<p>However, as far as the System V AMD64 ABI is concerned, this <em>is</em> a function, and we&rsquo;ll be able to call it from Zig. Given the ABI calling convention, we know that the first argument is passed in <code>rdi</code> and the second in <code>rsi</code>, and we know that we should put the result in <code>rax</code>. The <code>BITS 64</code> directive tells NASM to produce 64-bit machine code.</p>
<p>Let&rsquo;s assemble it:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>nasm -f bin -o asm-add.bin asm-add.s
</span></span></code></pre></div><p>Thanks to <code>-f bin</code>, this will produce a file called <code>asm-add.bin</code> containing the raw machine code, with no metadata like headers and sections. Just raw machine code for each instruction in the assembly file.</p>
<p>Let&rsquo;s disassemble it to verify that claim:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>ndisasm -b <span style="color:#ae81ff">64</span> asm-add.bin
</span></span></code></pre></div><p>This will output the same instructions as in the assembly file:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-plain" data-lang="plain"><span style="display:flex;"><span>hexdump -C asm-add.bin 
</span></span><span style="display:flex;"><span>00000000  48 89 f8 48 01 f0 c3
</span></span></code></pre></div><p>That&rsquo;s 7 bytes of machine code to add two numbers:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-plain" data-lang="plain"><span style="display:flex;"><span>; 0x48 is the REX prefix to indicate 64-bit operands
</span></span><span style="display:flex;"><span>; 0x89 is the MOV instruction
</span></span><span style="display:flex;"><span>; 0xf8 is the MOD R/M byte to specify the source and destination registers
</span></span><span style="display:flex;"><span>48 89 f8: mov rax, rdi
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>; 0x48 is the REX prefix
</span></span><span style="display:flex;"><span>; 0x01 is the ADD instruction
</span></span><span style="display:flex;"><span>; 0xf0 is the MOD R/M byte to specify operand registers
</span></span><span style="display:flex;"><span>48 01 f0: add rax, rsi
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>; 0xc3 is simply the RET instruction. It pops the return address from the stack and jumps to it 
</span></span><span style="display:flex;"><span>; The return address is placed there by the CALL instruction that Zig generates.
</span></span><span style="display:flex;"><span>c3: ret
</span></span></code></pre></div><h2 id="calling-from-zig">Calling from Zig<a hidden class="anchor" aria-hidden="true" href="#calling-from-zig">#</a></h2>
<p>Next, let&rsquo;s call the <em>add</em> function from Zig.</p>
<p>The process is roughly as follows:</p>
<ul>
<li>Allocate a page of memory</li>
<li>Write the machine code to the page. The machine code is loaded at compile time with <code>@embedFile</code></li>
<li>Mark the page as readable and executable using <code>mprotect</code></li>
<li>Cast the address of the buffer to a function pointer</li>
<li>Call the function</li>
</ul>
<p><code>asm.zig</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-zig" data-lang="zig"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> std <span style="color:#f92672">=</span> @import(<span style="color:#e6db74">&#34;std&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> main() <span style="color:#f92672">!</span><span style="color:#66d9ef">void</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">const</span> code <span style="color:#f92672">=</span> <span style="color:#66d9ef">try</span> std.heap.page_allocator.alignedAlloc(<span style="color:#66d9ef">u8</span>, @intCast(std.heap.pageSize()), std.heap.pageSize());
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">defer</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// In order to deallocate, we have to make the page writable again
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        _ <span style="color:#f92672">=</span> std.c.mprotect(@ptrCast(code), std.heap.pageSize(), std.c.PROT.WRITE);
</span></span><span style="display:flex;"><span>        std.heap.page_allocator.free(code);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Wrap the code page in a buffer stream and write the machine code to it
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">var</span> buf <span style="color:#f92672">=</span> std.io.fixedBufferStream(code);
</span></span><span style="display:flex;"><span>    _ <span style="color:#f92672">=</span> <span style="color:#66d9ef">try</span> buf.write(@embedFile(<span style="color:#e6db74">&#34;asm-add.bin&#34;</span>));
</span></span><span style="display:flex;"><span>    _ <span style="color:#f92672">=</span> std.c.mprotect(@ptrCast(code), std.heap.pageSize(), std.c.PROT.READ <span style="color:#f92672">|</span> std.c.PROT.EXEC);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Make a Zig function pointer for adding two u64s and returning the result
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">const</span> add<span style="color:#f92672">:</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">fn</span> (a<span style="color:#f92672">:</span> <span style="color:#66d9ef">u64</span>, b<span style="color:#f92672">:</span> <span style="color:#66d9ef">u64</span>) callconv(.C) <span style="color:#66d9ef">u64</span> <span style="color:#f92672">=</span> @ptrCast(code);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Call the machine code through the function pointer
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// This will put the arguments into rdi and rsi, and return the result in rax
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">const</span> res <span style="color:#f92672">=</span> add(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>);
</span></span><span style="display:flex;"><span>    std.debug.print(<span style="color:#e6db74">&#34;Res = {d}</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, .{res});
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Let&rsquo;s run it:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-zig" data-lang="zig"><span style="display:flex;"><span>zig run <span style="color:#66d9ef">asm</span>.zig
</span></span><span style="display:flex;"><span>Res <span style="color:#f92672">=</span> <span style="color:#ae81ff">3</span>
</span></span></code></pre></div><p>The structure is pretty nice: all the assembly code is in a separate file, and we can call it from Zig with no overhead beyond using registers for arguments, according to a specific calling convention.</p>
<p>If multiple CPU architectures are supported, the correct machine code file can be selected at compile time, typically by switching on <code>builtin.cpu.arch</code></p>
<p>Let&rsquo;s take a quick look at what Zig generates for the <code>add(1,2)</code> call:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-as" data-lang="as"><span style="display:flex;"><span><span style="color:#a6e22e">mov</span>     <span style="color:#a6e22e">rax</span><span style="color:#f92672">,</span> <span style="color:#a6e22e">qword</span> <span style="color:#a6e22e">ptr</span> [<span style="color:#a6e22e">rbp</span> <span style="color:#f92672">-</span> <span style="color:#ae81ff">96</span>]
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">mov</span>     <span style="color:#a6e22e">edi</span><span style="color:#f92672">,</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">mov</span>     <span style="color:#a6e22e">esi</span><span style="color:#f92672">,</span> <span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">call</span>    <span style="color:#a6e22e">rax</span>
</span></span></code></pre></div><p>The first line puts the pointer to the <em>add</em> function into <code>rax</code>. The next two lines put the arguments into <code>edi</code> and <code>esi</code>, and the last line calls the function that was loaded into <code>rax</code>. Note that edi/esi are the 32-bit lower halves of rdi/rsi - the upper halves are zeroed out, and thus reading rdi/rsi will work as expected in the <em>add</em> implementation.</p>
<h2 id="a-larger-example-with-fast-memcpy-and-syscalls">A larger example with fast memcpy and syscalls<a hidden class="anchor" aria-hidden="true" href="#a-larger-example-with-fast-memcpy-and-syscalls">#</a></h2>
<p>Here&rsquo;s an expanded version of the example, with two more functions: an AVX based memcpy, and an example of using syscalls to print a string to stdout.</p>
<p><code>asm.zig</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-zig" data-lang="zig"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> std <span style="color:#f92672">=</span> @import(<span style="color:#e6db74">&#34;std&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> main() <span style="color:#f92672">!</span><span style="color:#66d9ef">void</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">const</span> code <span style="color:#f92672">=</span> <span style="color:#66d9ef">try</span> std.heap.page_allocator.alignedAlloc(<span style="color:#66d9ef">u8</span>, @intCast(std.heap.pageSize()), std.heap.pageSize());
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">defer</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// In order to deallocate, we have to make the page writable again
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        _ <span style="color:#f92672">=</span> std.c.mprotect(@ptrCast(code), std.heap.pageSize(), std.c.PROT.WRITE);
</span></span><span style="display:flex;"><span>        std.heap.page_allocator.free(code);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Wrap the code page in a buffer stream and write the machine code to it
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">var</span> buf <span style="color:#f92672">=</span> std.io.fixedBufferStream(code);
</span></span><span style="display:flex;"><span>    _ <span style="color:#f92672">=</span> <span style="color:#66d9ef">try</span> buf.write(@embedFile(<span style="color:#e6db74">&#34;asm-add.bin&#34;</span>));
</span></span><span style="display:flex;"><span>    _ <span style="color:#f92672">=</span> std.c.mprotect(@ptrCast(code), std.heap.pageSize(), std.c.PROT.READ <span style="color:#f92672">|</span> std.c.PROT.EXEC);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Make a Zig function pointer for adding two u64s and returning the result
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">const</span> add<span style="color:#f92672">:</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">fn</span> (a<span style="color:#f92672">:</span> <span style="color:#66d9ef">u64</span>, b<span style="color:#f92672">:</span> <span style="color:#66d9ef">u64</span>) callconv(.C) <span style="color:#66d9ef">u64</span> <span style="color:#f92672">=</span> @ptrCast(code);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Call the machine code through the function pointer
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">const</span> res <span style="color:#f92672">=</span> add(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>);
</span></span><span style="display:flex;"><span>    std.debug.print(<span style="color:#e6db74">&#34;Res = {d}</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, .{res});
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Fast memcpy
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    _ <span style="color:#f92672">=</span> std.c.mprotect(@ptrCast(code), std.heap.pageSize(), std.c.PROT.WRITE);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">try</span> buf.seekTo(<span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>    _ <span style="color:#f92672">=</span> <span style="color:#66d9ef">try</span> buf.write(@embedFile(<span style="color:#e6db74">&#34;asm-opt-memcpy.bin&#34;</span>));
</span></span><span style="display:flex;"><span>    _ <span style="color:#f92672">=</span> std.c.mprotect(@ptrCast(code), std.heap.pageSize(), std.c.PROT.READ <span style="color:#f92672">|</span> std.c.PROT.EXEC);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// This memcpy requires the destination and source to be aligned to 32 bytes, and len to be a multiple of 64 bytes
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">const</span> fast_memcpy<span style="color:#f92672">:</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">fn</span> (dst<span style="color:#f92672">:</span> <span style="color:#66d9ef">u64</span>, src<span style="color:#f92672">:</span> <span style="color:#66d9ef">u64</span>, len<span style="color:#f92672">:</span> <span style="color:#66d9ef">u64</span>) callconv(.C) <span style="color:#f92672">?</span>[<span style="color:#f92672">*</span>]<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">u8</span> <span style="color:#f92672">=</span> @ptrCast(code);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">const</span> dst <span style="color:#f92672">=</span> <span style="color:#66d9ef">try</span> std.heap.page_allocator.alignedAlloc(<span style="color:#66d9ef">u8</span>, <span style="color:#ae81ff">32</span>, <span style="color:#ae81ff">64</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">const</span> src <span style="color:#f92672">=</span> <span style="color:#66d9ef">try</span> std.heap.page_allocator.alignedAlloc(<span style="color:#66d9ef">u8</span>, <span style="color:#ae81ff">32</span>, <span style="color:#ae81ff">64</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">const</span> test_bytes <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;0123456789012345678901234567890123456789012345678901234567891234&#34;</span>;
</span></span><span style="display:flex;"><span>    @memcpy(src, test_bytes);
</span></span><span style="display:flex;"><span>    _ <span style="color:#f92672">=</span> fast_memcpy(@intFromPtr(dst.ptr), @intFromPtr(src.ptr), <span style="color:#ae81ff">64</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (std.mem.eql(<span style="color:#66d9ef">u8</span>, test_bytes, dst)) {
</span></span><span style="display:flex;"><span>        std.debug.print(<span style="color:#e6db74">&#34;fast_memcpy works!</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, .{});
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        std.debug.print(<span style="color:#e6db74">&#34;fast_memcpy failed!</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, .{});
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">try</span> std.testing.expectEqualStrings(test_bytes, dst);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Next machine code file writes a message to stdout
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    _ <span style="color:#f92672">=</span> std.c.mprotect(@ptrCast(code), std.heap.pageSize(), std.c.PROT.WRITE);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">try</span> buf.seekTo(<span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>    _ <span style="color:#f92672">=</span> <span style="color:#66d9ef">try</span> buf.write(@embedFile(<span style="color:#e6db74">&#34;asm-syscall.bin&#34;</span>));
</span></span><span style="display:flex;"><span>    _ <span style="color:#f92672">=</span> std.c.mprotect(@ptrCast(code), std.heap.pageSize(), std.c.PROT.READ <span style="color:#f92672">|</span> std.c.PROT.EXEC);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">const</span> hello_world<span style="color:#f92672">:</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">fn</span> (msg<span style="color:#f92672">:</span> <span style="color:#f92672">?</span>[<span style="color:#f92672">*:</span><span style="color:#ae81ff">0</span>]<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">u8</span>, len<span style="color:#f92672">:</span> <span style="color:#66d9ef">u64</span>) callconv(.C) <span style="color:#66d9ef">void</span> <span style="color:#f92672">=</span> @ptrCast(code);
</span></span><span style="display:flex;"><span>    hello_world(<span style="color:#e6db74">&#34;Hello, world!!!</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, <span style="color:#ae81ff">16</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Below are the two new assembly files.</p>
<p><code>asm-opt-memcpy.s</code></p>
<p>In this case, we do need the function prologue and epilogue, because we&rsquo;re using the stack to store the arguments and local variables.</p>
<p>This source is based on a disassembly on Compiler Explorer.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-nasm" data-lang="nasm"><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">[</span><span style="color:#66d9ef">BITS</span> <span style="color:#ae81ff">64</span>]
</span></span><span style="display:flex;"><span>fast_memcpy:
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">push</span>    rbp
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">mov</span>     rbp, rsp
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">and</span>     rsp, <span style="color:#f92672">-</span><span style="color:#ae81ff">32</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">sub</span>     rsp, <span style="color:#ae81ff">256</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">mov</span>     <span style="color:#66d9ef">qword</span> [rsp <span style="color:#f92672">+</span> <span style="color:#ae81ff">104</span>], rdi
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">mov</span>     <span style="color:#66d9ef">qword</span> [rsp <span style="color:#f92672">+</span> <span style="color:#ae81ff">96</span>], rsi
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">mov</span>     <span style="color:#66d9ef">qword</span> [rsp <span style="color:#f92672">+</span> <span style="color:#ae81ff">88</span>], rdx
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">mov</span>     <span style="color:#66d9ef">qword</span> [rsp <span style="color:#f92672">+</span> <span style="color:#ae81ff">80</span>], <span style="color:#ae81ff">64</span>
</span></span><span style="display:flex;"><span>.LBB1_1:
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">cmp</span>     <span style="color:#66d9ef">qword</span> [rsp <span style="color:#f92672">+</span> <span style="color:#ae81ff">88</span>], <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">je</span>      .LBB1_3
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">mov</span>     rax, <span style="color:#66d9ef">qword</span> [rsp <span style="color:#f92672">+</span> <span style="color:#ae81ff">96</span>]
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">mov</span>     <span style="color:#66d9ef">qword</span> [rsp <span style="color:#f92672">+</span> <span style="color:#ae81ff">120</span>], rax
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">mov</span>     rax, <span style="color:#66d9ef">qword</span> [rsp <span style="color:#f92672">+</span> <span style="color:#ae81ff">120</span>]
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">vmovdqa</span> ymm0, [rax]
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">vmovdqa</span> [rsp <span style="color:#f92672">+</span> <span style="color:#ae81ff">32</span>], ymm0
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">mov</span>     rax, <span style="color:#66d9ef">qword</span> [rsp <span style="color:#f92672">+</span> <span style="color:#ae81ff">96</span>]
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">add</span>     rax, <span style="color:#ae81ff">32</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">mov</span>     <span style="color:#66d9ef">qword</span> [rsp <span style="color:#f92672">+</span> <span style="color:#ae81ff">112</span>], rax
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">mov</span>     rax, <span style="color:#66d9ef">qword</span> [rsp <span style="color:#f92672">+</span> <span style="color:#ae81ff">112</span>]
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">vmovdqa</span> ymm0, [rax]
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">vmovdqa</span> [rsp], ymm0
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">mov</span>     rax, <span style="color:#66d9ef">qword</span> [rsp <span style="color:#f92672">+</span> <span style="color:#ae81ff">104</span>]
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">vmovdqa</span> ymm0, [rsp <span style="color:#f92672">+</span> <span style="color:#ae81ff">32</span>]
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">mov</span>     <span style="color:#66d9ef">qword</span> [rsp <span style="color:#f92672">+</span> <span style="color:#ae81ff">232</span>], rax
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">vmovdqa</span> [rsp <span style="color:#f92672">+</span> <span style="color:#ae81ff">192</span>], ymm0
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">vmovdqa</span> ymm0, [rsp <span style="color:#f92672">+</span> <span style="color:#ae81ff">192</span>]
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">mov</span>     rax, <span style="color:#66d9ef">qword</span> [rsp <span style="color:#f92672">+</span> <span style="color:#ae81ff">232</span>]
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">vmovntdq</span>        [rax], ymm0
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">mov</span>     rax, <span style="color:#66d9ef">qword</span> [rsp <span style="color:#f92672">+</span> <span style="color:#ae81ff">104</span>]
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">add</span>     rax, <span style="color:#ae81ff">32</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">vmovdqa</span> ymm0, [rsp]
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">mov</span>     <span style="color:#66d9ef">qword</span> [rsp <span style="color:#f92672">+</span> <span style="color:#ae81ff">184</span>], rax
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">vmovdqa</span> [rsp <span style="color:#f92672">+</span> <span style="color:#ae81ff">128</span>], ymm0
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">vmovdqa</span> ymm0, [rsp <span style="color:#f92672">+</span> <span style="color:#ae81ff">128</span>]
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">mov</span>     rax, <span style="color:#66d9ef">qword</span> [rsp <span style="color:#f92672">+</span> <span style="color:#ae81ff">184</span>]
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">vmovntdq</span>        [rax], ymm0
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">mov</span>     rcx, <span style="color:#66d9ef">qword</span> [rsp <span style="color:#f92672">+</span> <span style="color:#ae81ff">80</span>]
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">mov</span>     rax, <span style="color:#66d9ef">qword</span> [rsp <span style="color:#f92672">+</span> <span style="color:#ae81ff">88</span>]
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">sub</span>     rax, rcx
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">mov</span>     <span style="color:#66d9ef">qword</span> [rsp <span style="color:#f92672">+</span> <span style="color:#ae81ff">88</span>], rax
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">mov</span>     rax, <span style="color:#66d9ef">qword</span> [rsp <span style="color:#f92672">+</span> <span style="color:#ae81ff">80</span>]
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">add</span>     rax, <span style="color:#66d9ef">qword</span> [rsp <span style="color:#f92672">+</span> <span style="color:#ae81ff">96</span>]
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">mov</span>     <span style="color:#66d9ef">qword</span> [rsp <span style="color:#f92672">+</span> <span style="color:#ae81ff">96</span>], rax
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">mov</span>     rax, <span style="color:#66d9ef">qword</span> [rsp <span style="color:#f92672">+</span> <span style="color:#ae81ff">80</span>]
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">add</span>     rax, <span style="color:#66d9ef">qword</span> [rsp <span style="color:#f92672">+</span> <span style="color:#ae81ff">104</span>]
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">mov</span>     <span style="color:#66d9ef">qword</span> [rsp <span style="color:#f92672">+</span> <span style="color:#ae81ff">104</span>], rax
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">jmp</span>     .LBB1_1
</span></span><span style="display:flex;"><span>.LBB1_3:
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">mov</span>     rsp, rbp
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">pop</span>     rbp
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">vzeroupper</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">ret</span>
</span></span></code></pre></div><p><code>asm-syscall.s</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-nasm" data-lang="nasm"><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">[</span><span style="color:#66d9ef">BITS</span> <span style="color:#ae81ff">64</span>]
</span></span><span style="display:flex;"><span><span style="color:#75715e">; set up syscall arguments</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">mov</span>     rdx, rsi
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">mov</span>     rsi, rdi
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">; pick the write syscall on macOS</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">mov</span>     rax, <span style="color:#ae81ff">0x2000004</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">; stdout</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">mov</span>     rdi, <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">; invoke</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">syscall</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-zig" data-lang="zig"><span style="display:flex;"><span>zig run <span style="color:#66d9ef">asm</span>.zig
</span></span><span style="display:flex;"><span>Res <span style="color:#f92672">=</span> <span style="color:#ae81ff">3</span>
</span></span><span style="display:flex;"><span>fast_memcpy works<span style="color:#f92672">!</span>
</span></span><span style="display:flex;"><span>Hello, world<span style="color:#f92672">!!!</span>
</span></span></code></pre></div><p><em>Edited July 2025. Code examples now compile with Zig 0.14.1. Added notes about using Rosetta on macOS.</em></p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
  </footer>
</article>
    </main>
     </body>

</html>
